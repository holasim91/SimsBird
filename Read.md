# Frontend 개발자가 알아야만 하는 웹지식
    전통적인 웹 
    요청 방식 : 브라우저 ->  프론트엔드 -> 백엔드 -> DB -> 백엔드 -> 프론트엔드 -> 브라우저(Server Side Rendering)
    장/단점: 화면 전체가 한 번에 그려진다는 장점이 있지만, 과정이 길기 때문에 로딩 속도가 길다.
                       
    SPA
    요청 방식 : 브라우져에서 데이터 없이 화면만 먼저 받고, 데이터는 로딩창이 돌아가는 동안 백엔드에서 직접 받아온다(프론트에서 합쳐서 보내는게 아니라)
    장/단점 :  모든 화면들을 다 가져와야하기 때문에(앞으로 바뀔 화면까지도) 전통적인 방법보다 느릴 수도 있으나, 로딩창을 띄우는것 즉 뭐라도 화면에 뜨기 때문에 유저들이 좀 더 쾌적한 환경에서 사용할 수 있다. 그러나 SEO에서 순위가 떨어질 수도 있다. 이 것을 해결하기위해 두가지 방법이 있는데. 하나가 SSR(Server Side Rendering)이고, 다른 하나는 Code Splitting(유저가 방문하기만 하는 페이지의 코드만 보내주는 기술)이다.
    SSR도 두 가지 방식이 있는데 하나는 Pre Render(SEO임을 감지하고 SEO일 때만 백엔드 서버에서 데이터를 받아서 html을 완성해서 보내주고, 일반 유저일때는 일반 리액트 방식으로 보내줌)고 다른 하나는 SSR(첫 방문만 전통적인 방식으로 하고, 그 다음부턴 리액트 방식)이다.

    ** 특정주소를 입력해서 들어갔을 때 로딩창이 없는 이유? 첫 방문이니까 SSR방식을 써서 보여주기 때문에 로딩창이 없다

# Next
    next에는 react-hot-loader가 적용되어 있어서 자동으로 새로고침이 된다
    
# 반응형
    프론트 화면을 개발할 때에는 무조건 모바일 화면부터 디자인하고 점점 늘려라.
    반대로하면.. 헬게이트 오픈!
    gutter: 컬럼사이에 간격을 주는 것

# Style(<div style={{...}}>인라인 스타일링 금지)
    스타일에 객체를 넣어선 안된다. 리렌더링 될 때마다 새로 생성되기 때문. JS에서 {} === {}는 false다. 따라서 리액트가 리렌더링 할 때 Virtual Dom과 비교를 하면서 다른 부분을 찾는데, 앞에서 얘기한 것 처럼 전혀 바뀐게 없는데도 불구하고 리렌더링을 실시하기 때문에, 성능이 떨어진다. 그래서 요것을 위해 Styled-Components를 사용한다    

# UseMemo VS UseCallback
     UseCallback는 함수를 캐싱해주는 것이고,  UseMemo는 값을 캐싱한다.

# 리렌더링
    함수형 컴포넌트에서 리렌더링이 된다고 함은 함수안의 있는 모든 것들이 다시 실행되는 것은 맞다. 하지면 UsecCallback은 캐싱이기 때문에 이전 컴포넌트와 현재 컴포넌트가 동일하다고 친다.(베열부분이 바뀌지 않는 이상) 하지만 return안에 있는 것들은 바뀐부분만 다시 실행된다. 

# Redux
    왜 쓰는가?
    -> 여러 컴포넌트에서 공통적으로 쓰이는 데이터가 있는데, 그 컴포넌트들은 따로따로 흩어져있고, 그에 띠리 데이터도 흩어져있으므로 부모컴포넌트에게 보내서 다시 자식 컴포넌트에게 각각 보내야하는데, 그런 과정들이 매번 수동을 해주기 번거로우니까 중앙에서 하나로 관리를 해서 중앙데이터 저장소 역할을 하기위함.(mobX, apollo등등..)
    
    ContextAPI vs Redux + Mobx
    -> 비동기를 지원하는가의 차이 (비동기를 다룰때는 실패를 다뤄야한다)

    action 을 dispatch하는 순간 type과 data가 reducer로 전달이 된다.

    reducer는 (이전상태,액션) => 다음상태

# 불변성
    JS에서 무적권 조심해야하는 개념
    {} === {} //false
    const a = {}
    const b = a
    a === b // true
    객체를 참조관계가 있으면 참이다.
    리덕스에서 왜 객체를 새로 만드는가? 새로 만들어야 변경내역이 추적이된다.
    ...state => 안바뀌는 애들은 참조관계를 유지하고 있어서 메모리가 정리된다.

# Array.map((f,idx)=><compoenet key={idx}>) 하지마잉
    key를 index로 잡는건 안티패턴중 하나다. 특히 삭제할 때(반복되는 것들이 지워질 가능성이 있을 때), 순서가 달라질 때, 중간에 무언가가 추가될 때에는 절대 하면 안된다. 왜냐하면

# Redux Thunk
    미들웨어다. 리덕스가 비동기 액션을 디스패치 할 수 있도록 해주는 역할을 한다. 이것의 장점은 하나의 액선에서 동기 액션을 여러번 할 수 있다는 것이다.(리덕스의 기능이 확장됨)     

# SAGA Effect
    all : all은 배열을 받고 그 안에 있는 것들을 한방에 실행한다.
    fork: 함수를 실행한다. 비동기 함수를 호출한다. 결과가 리턴되기도 전에 바로 다음것을 실행한다.
    call: 얘도 함수를 실행하는데 동기함수를 호출한다.
    put: 
    take: take안에 있는 액션이 실행될 때까지 기다리겠다. 근데 이건 딱 한번만 실행되기때문에, 안에 while문을 써야한다. 하지만 이 경우엔 동기적으로 동작하지만 코드가 직관적이지 않음
    takeEvery: take안의 while문을 대체하기위한 표현. 비동기적
    takeLatest: 마지막것만(동시에 로딩중인것만, 완료된 것은 나두고...프론트에서만 그렇게 생각함 즉 요청은 두번하는데 응답을 하나만 받는다 이밀이야) 실행
    takeLeading: 처음것만
    throttle: 지정한 시간안에 한 번만 요청할 수 있게한다.

# REST API
    GET: 가져오다
    POST: 생성하다
    PUT: 전체 수정
    DELETE: 제거
    PATCH: 부분 수정
    OPTIONS: 찔러보기(?)
    HEAD: 헤더만 가져오기

# CORS
    브라우저에서 서버로 요청을 보낼때만 발생됨. 서버에서 서버는 발행하지 않음.   
    Proxy: CORS를 피하기위해 요청 순서를 브라우저 -> 프론트 서버 -> 백서버 로함?  

# Session Cookie
    왜 필요한가? 로그인을 할 때 브라우져랑 서버랑 같은 정보를 저장해야하는데 브라우저는 누구나 접속할 수 있기에 해킹에 취약하므로 
             서버로부터 알 수 없는 문자열을 보내준다. 그거를 백엔드에서 받아 원래 것으로 복원할 수 있게

# Redis
    Redis는 Remote Dictionary Server의 약자로서, "키-값" 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터베이스 관리 시스템   

# 도메인이 다르면 쿠키도 전달이 안된다!!

# limit 과 offset
    limit은 정보를  입력한 정수개만큼 가져오라는거고, offset은 시작 번호를 알려주는듯
    예를들어, {limit: 10, offset:10}이면 11번부터 20번까지의 정보를 가져오라고 하는것